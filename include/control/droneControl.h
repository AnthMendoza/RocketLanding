#ifndef DRONECONTROL_H
#define DRONECONTROL_H 
#include <iostream>
#include <Eigen/Eigen>
#include <Eigen/Dense>
#include <vector>
#include "../subsystems/propeller.h"
using namespace Eigen;
using namespace std;
namespace SimCore{
/**
 * @brief ControlAllocator solves for rotor thrusts to achieve a desired net force and torque (wrench)
 *        based on rotor positions, thrust directions, and spin torque coefficients.
 */
class controlAllocator {
private:
    vector<Vector3d> positions;     // Motor positions in body frame
    vector<Vector3d> thrustDirs;   // Unit vectors for thrust direction
    VectorXd spinTorque;           // Spin torque coefficient for each motor
    MatrixXd B;         // CAS matrix (6 x N), mapping thrusts to net force/torque
    MatrixXd Bpinv;    // Pseudo-inverse of B for control allocation

    /**
     * @brief Builds the Control Allocation Matrix (CAS)
     *
     * Each column of the CAS matrix corresponds to the effect of a single motor's thrust on:
     * - The net force (Fx, Fy, Fz)
     * - The net torque (Tx, Ty, Tz)
     *
     * Force comes from thrust direction; torque comes from moment arm (r Ã— F) + spin torque.
     */
    void buildCASMatrix();
public:
    /**
     * @brief Constructor for the ControlAllocator
     * @param motorPositions   Vector of rotor positions in body frame (3D per rotor)
     * @param thrustDirections Vector of unit vectors representing thrust direction for each rotor
     * @param spinTCoefficent      Vector of spin torque coefficients (yaw torque per unit thrust)
     */
    controlAllocator(const vector<array<float,3>>& motorPositions,const vector<array<float,3>>& thrustDirections,vector<float> spinTCoefficent);
    /**
     * @brief Solves for the rotor thrusts required to produce the given wrench (force and torque).
     * @param desiredwrench 6D vector: [Fx, Fy, Fz, Tx, Ty, Tz]
     * @return Vector of individual motor thrusts
     */
    inline VectorXd allocate(const VectorXd& desiredwrench) const {
        // Use the precomputed pseudo-inverse of the CAS matrix
        VectorXd thrusts = Bpinv * desiredwrench;
        return thrusts;
    }

    /**
     * @brief Returns the internal control allocation matrix B (6 x N)
     */
    inline const MatrixXd& getCASMatrix() const {
        return B;
    }

    /**
     * @brief Computes the actual force/torque (wrench) generated by a given vector of thrusts
     * @param thrusts Vector of individual motor thrusts
     * @return 6D vector: [Fx, Fy, Fz, Tx, Ty, Tz]
     */
    inline VectorXd computeWrench(const VectorXd& thrusts) const {
        return B * thrusts;
    }

    VectorXd toVectorXd(std::initializer_list<float> list);

};

} //SimCore

#endif
